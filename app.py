# -*- coding: utf-8 -*-
"""Etude de cas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cwF4bveAdBPbU7HmbRwqQV3NnDY8Uq8u
"""

!pip install python-mnist

from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.datasets import make_classification
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline

from mnist import MNIST

import numpy as np

mndata = MNIST('train')
X_train, Y_train = mndata.load_training()

mndata = MNIST('test')
X_test, Y_test = mndata.load_testing()

try:
    if len(X_train[1]) == len(X_test[1]):
        nb_pixels = len(X_train[1])
except:
    print("The numbers of pixels of images in the train dataset and the test dataset are not the same, thus it is abnormal")

nb_images_train = int(len(X_train))

X_train_r = np.zeros((nb_images_train, nb_pixels, nb_pixels))

for i, x in enumerate(X_train):
    X_train_r[i] = np.array(x).reshape(nb_pixels, nb_pixels)
    
def show_train_images(i):
    return X_train_r[i]

Y_train_r = np.array(Y_train)
Y_test_r = np.array(Y_test)

pipe = Pipeline([('scaler', StandardScaler()), ('svc', SVC())])

pipe.fit(X_train, Y_train_r)

accuracy = pipe.score(X_test, Y_test_r)
print(accuracy)

import json
import numpy
import math
from PIL import Image

path_image = "2.jpg"
image = Image.open(path_image).resize((28, 28))
image.show()

data = numpy.asarray(image)

# if the image contains pixels RGB + Greyscale, keep only the Greyscale part
data_final = [data[i][j][3] for j in range(28) for i in range(28)]

#if the image contains pixels RGB, keep the average of each
data_final = []
for i in range(28):
  for j in range(28):
    x = 0
    for k in range(3):
      x += data[i][j][k]
    data_final.append(x/3)

def invert_image(image):
  image_reverse = []
  for x in image:
    image_reverse.append(abs(x - 255))
  return image_reverse

data_final_reverse = invert_image(data_final)

res = pipe.predict(np.array(data_final_reverse).reshape(1, -1))
print(res)

dictionnary = {
    "image": f'{path_image}',
     "prediction": f'{res[0]}',
     "accuracy": f'{accuracy}'
}

json_file = json.dumps(dictionnary, indent = 3, sort_keys = True)